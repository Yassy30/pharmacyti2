
import 'package:pharmaciyti/features/client/cart/viewmodel/cart_viewmodel.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class Order {
  final int? id; // Make id nullable since it's generated by Supabase
  final String userName;
  final String userPhone;
  final String userAddress;
  final List<CartItem> items;
  final double subtotal;
  final double deliveryFee;
  final double total;
  final String paymentMethod; // Expected: "Cash on Delivery" or "Online Payment"
  final String pharmacy;
  final String estimatedDelivery;
  final DateTime orderDate;

  Order({
    this.id, // Optional, will be set after insertion
    required this.userName,
    required this.userPhone,
    required this.userAddress,
    required this.items,
    required this.subtotal,
    required this.deliveryFee,
    required this.total,
    required this.paymentMethod,
    required this.pharmacy,
    required this.estimatedDelivery,
    required this.orderDate,
  });
}
class OrderRepository {
  final supabase = Supabase.instance.client;

  Future<int> saveOrder(Order order) async {
    try {
      // Récupérer l'ID de l'utilisateur connecté
      final user = supabase.auth.currentUser;
      if (user == null) {
        throw Exception('Utilisateur non connecté');
      }

      // Mapper la méthode de paiement pour correspondre à l'enum Supabase
      final paymentEnumValue = order.paymentMethod == 'Cash on Delivery' ? 'cash' : 'online';

      // 1. Ajouter la commande (laisser Supabase générer l'ID)
      final orderInsert = await supabase.from('orders').insert({
        'date': order.orderDate.toIso8601String(),
        'statut': 'pending',
        'price_total': order.total,
        'quantity': order.items.fold(0, (sum, item) => sum + item.quantity),
        'type_payment': paymentEnumValue,
        'user_id': user.id,
        // Add prescription_image_id if there's a prescription in the order
        'prescription_image_id': order.items.any((item) => item.name == 'Uploaded Prescription') 
            ? order.items.firstWhere((item) => item.name == 'Uploaded Prescription').id 
            : null,
      }).select('id').single(); // Récupérer uniquement l'ID

      final orderId = orderInsert['id'] as int;

      // 2. Ajouter les médicaments commandés
      for (final item in order.items) {
        await supabase.from('order_medicines').insert({
          'order_id': orderId,
          'medicine_id': item.id,
        });
      }

      // 3. Ajouter les infos de livraison
      await supabase.from('delivery').insert({
        'date_delivery': order.orderDate.toIso8601String(),
        'date': order.orderDate.toIso8601String(),
        'localisation_delivery': order.userAddress,
        'order_id': orderId,
      });

      // 4. Ajouter le paiement
      await supabase.from('payments').insert({
        'sum': order.total,
        'method': paymentEnumValue,
        'date': order.orderDate.toIso8601String(),
        'status': 'pending',
        'order_id': orderId,
      });

      print('✅ Commande enregistrée avec succès ! ID: $orderId');
      return orderId; // Return the order ID
    } catch (e) {
      print('❌ Exception lors de la sauvegarde de la commande: $e');
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> getOrdersByUser(String userId) async {
    final response = await supabase
        .from('orders')
        .select()
        .eq('user_id', userId)
        .order('created_at', ascending: false);
    if (response == null) {
      throw Exception('Failed to fetch orders');
    }
    return List<Map<String, dynamic>>.from(response);
  }
}
